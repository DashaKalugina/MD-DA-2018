---
output:
  html_document: default
  pdf_document: default
---
### Студент: Калугина Дарья
### Группа: РИ-450004
# Домашнее задание № 1
## Работа с данными.
По адресу http://people.math.umass.edu/~anna/Stat597AFall2016/rnf6080.dat можно получить набор данных об осадках в Канаде с 1960 по 1980 годы. Необходимо загрузить эти данные при помощи ``read.table``. Воспользуйтесь справкой, чтобы изучить аргументы, которые принимает функция. 
- Загрузите данные в датафрейм, который назовите ``data.df``
```{r}
data.df <- read.table(file = "http://people.math.umass.edu/~anna/Stat597AFall2016/rnf6080.dat")
```
- Сколько строк и столбцов в ``data.df``? Если получилось не 5070 наблюдений 27 переменных, то проверяйте аргументы.

Полученный датафрейм имеет `r nrow(data.df)` строк и `r ncol(data.df)` столбцов.

- Получите имена колонок из ``data.df``.
```{r}
options(width = 4000)
data.df_names <- names(data.df) # получить имена переменных, входящих в таблицу данных
data.df_names
```
- Найдите значение из 5 строки седьмого столбца.
```{r}
# два способа:
data.df[[7]][5]
data.df[5,7]
```
- Напечатайте целиком 2 строку из ``data.df``
```{r}
data.df[2,]
```
- Объясните, что делает следующая строка кода ``names(data.df) <- c("year", "month", "day", seq(0,23))``. Воспользуйтесь функциями ``head`` и ``tail``, чтобы просмотреть таблицу. Что представляют собой последние 24 колонки?
```{r}
names(data.df) <- c("year", "month", "day", seq(0,23))
```

Данная строка кода назначает колонкам таблицы (т.е. переменным, для которых проводились измерения) новые имена "year", "month, "day", "0", "1" и т.д. вместо "V1", "V2", "V3" и т.д.

```{r}
head(data.df, n=5) # просмотр первых пяти значений каждой переменной, входящей в таблицу
tail(data.df, n=10) # просмотр последних 10 значений каждой переменной, входящей в таблицу
```

В последних 24 колонках датафрейма содержится информация о количестве осадков за каждый час в течение суток (каждая строка таблицы соответствует одному дню).

- Добавьте новую колонку с названием *daily*, в которую запишите сумму крайних правых 24 колонок. Постройте гистограмму по этой колонке. Какие выводы можно сделать?
```{r}
data.df$daily <- rowSums(data.df[,4:27])
hist(data.df$daily, xlab = "Суточное количество осадков", ylab = "Частота встречаемости", main = "Гистограмма суточного кол-ва осадков за 1960-1980 г.", freq = TRUE, col="aquamarine", breaks = 50)
```

Полученная гистограмма отображается некорректно. В столбце _daily_ есть отрицательные значения, поскольку часть ячеек датафрейма содержит значения _-999_. Поэтому при суммировании получаются большие отрицательные значения.

- Создайте новый датафрейм ``fixed.df`` в котором исправьте замеченную ошибку. Постройте новую гистограмму, поясните почему она более корректна.

```{r}
fixed.df <- data.df
for (i in 1:nrow(fixed.df)){
  for (j in 1:ncol(fixed.df)){
    if (fixed.df[i,j]==-999)
      fixed.df[i,j]<-0
  }
}
fixed.df$daily <- rowSums(fixed.df[,4:27])

```

```{r}
hist(fixed.df$daily, xlab = "Суточное количество осадков", ylab = "Частота встречаемости", main = "Гистограмма суточного кол-ва осадков за 1960-1980 г.", freq = TRUE, col="aquamarine", breaks = 50)
```

Полученная выше гистограмма более корректна, т.к. она не отображает частоту встречаемости отрицательных значений количества осадков.

## Синтаксис и типизирование
* Для каждой строки кода поясните полученный результат, либо объясните почему она ошибочна.

```{r}
v <- c("4", "8", "15", "16", "23", "42")
max(v)
sort(v)
# sum(v)
```

Функции ``max()`` и``sort()`` являются корректными в отношении векторов строк, т.к. могут принимать в качестве входных аргументов как числовые, так и строковые векторы. Строки при этом сортируются в лексикографическом порядке на основе ASCII-кодов символов.

Применение функции суммы для символьного вектора является ошибочным, поскольку функция ``sum()`` работает только с числовыми и логическими типами данных.

* Для следующих наборов команд поясните полученный результат, либо объясните почему они ошибочны.
```{r}
v2 <- c("5",7,12)
#v2[2] + v2[3]
```

Вектор представляет собой объект, содержащий набор однотипных элементов. Поэтому в данном случае значения _7_ и _12_ будут конвертированы в  строковый тип данных. Строка кода ``v2[2] + v2[3]`` является ошибочной, т.к. вектор _v2_ состоит из строк, а операция суммы к типу данных _character_ неприменима:
```{r}
str(v2) # структура вектора
typeof(v2) # тип элементов вектора v2
```

```{r}
df3 <- data.frame(z1="5",z2=7,z3=12)
df3[1,2] + df3[1,3]
```

В датафреймах (таблицах данных) колонки (переменные могут иметь разный тип данных). Из результата команды ```str(df3)`` видно, что колонка _z1_ состоит из данных номинального типа (текстовое значение _"5"_ было конвертировано в фактор и пока в колонке присутствет только уровень _"5"_), а _z2_ и _z3_ являются числовыми. Следовательно, операция сложения применима к значениям из колонок _z2_ и _z3_.

```{r}
df3
str(df3) # структура датафрейма
```

```{r}
l4 <- list(z1="6", z2=42, z3="49", z4=126)
l4[[2]] + l4[[4]]
#l4[2] + l4[4]
```

Список представлет собой последовательность значений различного типа. Получать доступ к элементам вектора можно при помощи одинарных или двойных квадратных скобок. При выборе элементов списка одинарными квадратными скобками получаемый объект тоже будет списком, а при использовании двойных квадратных скобок объект будет того типа, каким он был до объединения в список. Поэтому в строке кода ``l4[[2]] + l4[[4]]`` будут складываться числовые значения, а строка ``l4[2] + l4[4]`` приведет к ошибке (т.к. невозможно сложить два списка).

## Работа с функциями и операторами
* Оператор двоеточие создаёт последовательность целых чисел по порядку. Этот оператор — частный случай функции ``seq()``, которую вы использовали раньше. Изучите эту функцию, вызвав команду ``?seq``. Испольуя полученные знания выведите на экран:
  1. Числа от 1 до 10000 с инкрементом 372. 
```{r}
seq.1 <- seq(from=1, to=10000, by=372)
print(seq.1) # полученная последовательность
length(seq.1) # длина последовательности
```

  2. Числа от 1 до 10000 длиной 50.
```{r}
seq.2 <- seq(from=  1, to = 10000, length.out = 50)
print(seq.2) # полученная последовательность
length(seq.2) # длина последовательности
```
* Функция ``rep()`` повторяет переданный вектор указанное число раз. Объясните разницу между ``rep(1:5,times=3)`` и ``rep(1:5, each=3)``.
```{r}
rep(1:5,times=3)
rep(1:5, each=3)
```

По умолчанию функция ``rep()`` повторяет переданный вектор один раз (_times=1_). Параметр _times_ указывает, сколько раз нужно повторить _всю_ последовательность, а параметр _each_ - сколько раз нужно повторить сначала _первый_ элемент последовательности, затем _второй_ и т.д.