#####Студент:  Калугина Дарья
#####Группа:   РИ-450004
# Лабораторная работа 2
## Задачи для лабораторной: 
* манипулирование объектами данных;
* работа с циклами;
* переписывание существующего кода;
* моделирование при помощи генератора случайных величин.

## Исходные данные
Установленная среда R включает в себя набор заранее сконфигурированных массивов данных.
В данной лабораторной требуется использовать одну из них  — датафрейм из 93 машин-новинок 1993 года.
Для того, чтобы загрузить данный датафрейм, необходимо выполнить следующие команды:

```{r}
library(MASS)
data(Cars93)
```
Для того, чтобы ознакомиться со структурой и составом данных, можно выполнить команду ``View(Cars93)`` 
или нажать на соответствующую кнопку в RStudio.

### Задание 1
1. Выполните команду ``summary()`` на полном наборе данных. Можно ли по результату выполнения сказать сколько строк в датафрейме?
Если да, напишите сколько. Если нет, то приведите другой способ.
```{r}
summary(Cars93)
```

Функция ``summary()`` не выводит информацию о том, сколько строк содержит датафрейм, т.к. результатом выполнения этой функции является вывод основных статистических характеристик (например, минимального и максимального значения, среднего арифметического) по каждой переменной (производитель, модель, тип, цена, расход топлива и т.д.). Если переменная является номинальной (например, _Manufacturer_), то подсчитывается количество наблюдений для каждого значения ( _Chevrolet_ , _Ford_ и т.д.). Однако, узнать количество строк в датафрейме можно посчитав сумму количества наблюдений по каждому значению номинальной переменной (например, по переменной _Type_: ``16+11+22+21+14+9=93``)

Другой способ узнать количество строк в датафрейме (т.е. количество машин):
```{r}
nrow(Cars93)
```

2. Найдите среднюю цену машин с задним приводом.
```{r}
price.cars.rwd <- Cars93$Price[Cars93$DriveTrain == "Rear"]
price.cars.rwd # цены на машины с задним приводом 
mean.price.rwd <- mean(price.cars.rwd)
mean.price.rwd # средняя цена на машины с задним приводом
```
3. Найдите минимальное число лошадиных сил автомобиля для 7 пассажиров. Для 6 пассажиров.
```{r}
horsepower.cars.7.pass <- Cars93$Horsepower[Cars93$Passengers == 7]
min(horsepower.cars.7.pass) # минимальное число лошадиных сил автомобиля для 7 пассажиров
horsepower.cars.6.pass <- Cars93$Horsepower[Cars93$Passengers == 6]
min(horsepower.cars.6.pass) # минимальное число лошадиных сил автомобиля для 6 пассажиров
```
4. Найдите машины с максимальным, минимальным и средним(медианой) расстоянием, которая машина может проехать по трассе.
Вам понадобятся 2 колонки, чтобы рассчитать расстояние. Какие?

Для того чтобы рассчитать расстояние, понадобятся столбцы _MPG.highway_ (сколько миль машина может проехать по трассе на одном галлоне топлива) и _Fuel.tank.capacity_ (емкость топливного бака).
```{r}
distances <- Cars93$MPG.highway*Cars93$Fuel.tank.capacity
min(distances) # минимальное расстояние
median(distances) # среднее расстояние
max(distances) # максимальное расстояние

vars <- c("Manufacturer", "Model", "Type", "MPG.highway", "Fuel.tank.capacity")

library(knitr)

# машина с минимальным расстоянием
car.min.dist <- Cars93[Cars93$MPG.highway*Cars93$Fuel.tank.capacity == min(distances),vars]
kable(car.min.dist)

# машина со средним расстоянием
car.median.dist <- Cars93[Cars93$MPG.highway*Cars93$Fuel.tank.capacity == median(distances),vars]
kable(car.median.dist)

# машина с максимальным расстоянием
car.max.dist <- Cars93[Cars93$MPG.highway*Cars93$Fuel.tank.capacity == max(distances),vars]
kable(car.max.dist)
```

## Задание 2
В самом начале занятий приводился пример с фабрикой и производством автомобилей.
Ниже приведён пример кода, который старается оптимизировать выпуск продукции ориентируясь на доступные ресурсы.
```{r}
factory.run <- function (o.cars=1, o.trucks=1) {
  factory <- matrix(c(40,1,60,3),nrow=2, dimnames=list(c("трудодни","сталь"),c("автомобили","грузовики")))
  warehouse <- c(1600,70) #Доступно материалов на складе
  names(warehouse) <- rownames(factory)
  reserve <- c(8,1)
  names(reserve) <- rownames(factory)
  output <- c(o.cars, o.trucks)
  names(output) <- colnames(factory)
  
  steps <- 0 # Счётчик числа шагов цикла
  repeat {
    steps <- steps + 1
    needed <- factory %*% output # Подсчитаем ресурсы, которые нам нужны для производства требуемого кол-ва машин
    #message(steps)
    #print(needed)
    # Если ресурсов достаточно и остаток меньше или равен резерву, то мы произвели максимум возможного.
    # Нужно прекращать
    if (all(needed <= warehouse) && all((warehouse - needed) <= reserve)) {
      break()
    }
    # Если заявка слишком большая и ресурсов недостаточно, уменьшим её на 10%
    if (all(needed > warehouse)) {
      output <- output * 0.9
      next()
    }
    # Если всё наоброт, то увеличим на 10%
    if (all(needed < warehouse)) {
      output <- output * 1.1
      next()
    }
    # Если мы потребили одного ресурса слишком много, а другого недостаточно,
    # то увеличим план на случайную величину
    output <- output * (1+runif(length(output),min=-0.1,max=0.1))
  }
  message(steps)
  print(needed)
  return(output)
}
```
1. Выполните код и запустите эту функцию ``factory.run()``.
```{r}
factory.run()
```
2. С каким входными значениями функция вызвана? Какой получился результат?

Т.к. функции при вызове не были переданы входные параметры, то она была вызвана с входными параметрами по умолчанию ( _o.cars_ = 1, _o.trucks_ = 1 - одна машина и один грузовик). В результате в функции было сделано 305 итераций ( _steps_ = 305). Результаты выполнения функции показывают, что при имеющихся ресурсах максимальное количество автомобилей и грузовиков, которое может быть произведено, равно 9 и 20 соответственно. При этом объем ресурсов, необходимых для производства (переменная _needed_) на последнем шаге составил: 1597 трудодней, 69 стали.

3. Повторите вызов 4 раза. Полученные ответы отличаются от полученных ранее? Если да, почему? Если нет, почему?

```{r}
factory.run()
factory.run()
factory.run()
factory.run()
```

Результаты вызовов функции похожи, т.к. функции вызываются с одинаковыми входными параметрами, одними и теми же значениями переменных _factory_ (количество трудодней и стали, необходимых для выпуска одной машины и одного грузовика), _warehouse_ (объем доступных ресурсов), _reserve_ (резервным объемом ресурсов). 

Результаты выполнения показали следующие возможные значения количества произведенных машин и грузовиков: 9 и 19, 10 и 19, 9 и 20.

Различия в результатах выполнения функций объясняются тем, что при увеличении плана производства (переменной _output_) используется генерация случайных чисел (это объясняет разное получаемое количество прозведенных машин и грузовиков). Значит при каждом выполнении функция делает различное количество шагов до момента достижения условия выхода из цикла.

4. В приведённом коде, переменные _steps_ и _output_ находятся внутри алгоритма.
Измените функцию так, чтобы она возвращала число шагов и произведённое количество машин.
```{r}
factory.run.changed <- function (o.cars=1, o.trucks=1) {
  factory <- matrix(c(40,1,60,3),nrow=2, dimnames=list(c("трудодни","сталь"),c("автомобили","грузовики")))
  warehouse <- c(1600,70) #Доступно материалов на складе
  names(warehouse) <- rownames(factory)
  reserve <- c(8,1)
  names(reserve) <- rownames(factory)
  output <- c(o.cars, o.trucks)
  names(output) <- colnames(factory)
  
  steps <- 0 # Счётчик числа шагов цикла
  repeat {
    steps <- steps + 1
    needed <- factory %*% output # Подсчитаем ресурсы, которые нам нужны для производства требуемого кол-ва машин
    
    #message(steps)
    #print(needed)
    
    # Если ресурсов достаточно и остаток меньше или равен резерву, то мы произвели максимум возможного.
    # Нужно прекращать
    if (all(needed <= warehouse) && all((warehouse - needed) <= reserve)) {
      break()
    }
    # Если заявка слишком большая и ресурсов недостаточно, уменьшим её на 10%
    if (all(needed > warehouse)) {
      output <- output * 0.9
      next()
    }
    # Если всё наоброт, то увеличим на 10%
    if (all(needed < warehouse)) {
      output <- output * 1.1
      next()
    }
    # Если мы потребили одного ресурса слишком много, а другого недостаточно,
    # то увеличим план на случайную величину
    output <- output * (1+runif(length(output),min=-0.1,max=0.1))
  }
  message(steps)
  output <- append(output, needed)
  names(output) <- append(colnames(factory), rownames(factory))
  return(output)
}
```
5. Установите план равный тридцати автомобилям и 20 грузовикам и выполните функцию.

```{r}
factory.run.changed(30,20)
factory.run.changed(30,20)
factory.run.changed(30,20)
factory.run.changed(30,20)
```
   1. Какой получили результат?
   
   Полученные результаты аналогичны результатам выполнения функции при входных аргументах по умолчанию (одна машина и один грузовик), т.к. установленный план в 30 машин и 20 грузовиков не может быть выполнен, поскольку для этого бы потребовалось ``30*40 + 20*60 = 2400`` трудодней и ``1*30 + 3*20 = 90`` единиц стали. Требуемые значения ресурсов значительно превышают доступные, поэтому алгоритм будет уменьшать слишком большую заявку на 10%. Когда объем доступного будет превышать только значение трудодней и только стали, алгоритм будет уменьшать план на случайную величину. 
   
   2. Каким получился итоговый запрос ресурсов (переменная _needed_)
   
   Объем требуемых трудодней и стали в каждом случае получался примерно одинаковым: _1597.01394_ и _69.53068_, _1597.46623_ и _69.67542_, _1594.90461_ и _69.49385_, _1595.093886_ и _69.854081_.
   
   3. Как много итераций пришлось пройти, чтобы получить ответ (переменная _steps_)? 
   
   Количество пройденных итераций цикла для каждого случая существенно отличается: _3249_,  _144_, _1826_, _494_.
   
   4. Для подсчёта можно пользоваться функциями печати (``print``, ``message``) или вернуть результат из функции.